const webviewDetail = [
  {
    title: '웹뷰 메시지 통신의 구조적 개선을 위한 옵저버 패턴 적용',
    images: [],
    problem:
      '웹뷰 메시지를 처리하는 로직이 여러 컴포넌트에 중복되고 분산되어 있어, 메시지 흐름을 예측하기 어렵고 유지보수 및 확장 시 에러 발생 가능성이 높음',
    cause: [
      '각 컴포넌트가 자체적으로 메시지 리스너를 등록하고 처리하는 구조로 되어 있어, 동일한 이벤트 리스너 로직이 여러 곳에 중복되고, DRY 원칙을 위반하고 있음.',
      '메시지를 수신할 때 관심사에 따라 분리된 구조가 아닌 브로드캐스트 방식으로 전달되기 때문에, 관심 없는 메시지까지 수신하게 되고, 각 메시지 핸들러가 독립적으로 동작하면서 일관된 메시지 처리 흐름을 만들기 어려움',
    ],
    alternatives: [
      {
        text: '옵저버(Observer) 패턴을 적용해, 각 컴포넌트가 자신이 필요한 메시지 타입만 구독하도록 구성',
        selected: true,
      },
    ],
    solution: [
      'WebViewMessagePublisher 클래스를 도입하여 메시지를 중앙에서 수신하고, 옵저버들은 자신이 관심 있는 메시지 타입만 구독하도록 리팩터링하여 메시지 수신/처리의 관심사 분리와 일관성 확보를 달성함',
      '메시지 응답 타입을 제네릭(Generic)으로 정의하여, 옵저버 등록 시 타입을 명시적으로 전달하도록 구성함으로써 컴파일 타임에서의 타입 체크와 안전한 메시지 파싱이 가능해졌고, 메시지 구조 변경 시 런타임 에러 없이 즉각적인 대응이 가능하도록 하여 안정성을 높임',
    ],
    insights: [
      '메시지 처리 로직을 중앙에서 관리하게 되면서, 유형 추가나 메시지 스펙 변경에 대한 대응 비용도 감소하였고, 개발자가 특정 메시지가 어디서 처리되는지 파악하기 쉬워져 디버깅 효율도 향상되었다.',
      'WebViewMessagePublisher를 싱글톤 패턴으로 구현함으로써, 전역에서 동일한 인스턴스를 공유하며 메시지 수신 및 구독 관리의 일관성을 확보할 수 있었고, 중복 리스너 등록이나 메모리 누수에 대한 위험도 줄일 수 있었다.',
    ],
    references: [],
  },
];

export default webviewDetail;
